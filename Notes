# This is the Notes text file
=============================

1) Generate the nodelist for the given target

2) cuNode *nl;
	cudaMallocManaged( &nl, sizeof(cuNode) * nodelist.size() );
	for(int x = 0; x < nodelist.size(); +=x) *(nl+x) = nodelist[x];
	Given nThreads = 1024;
	nBlocks = (nodelist.size + nThreads - 1) / nThreads
	
3) Allocate a results area
	uint8_t *Results;
	cudaMallocManaged( &Results, sizeof(uint8_t) * nodelist.size() );
	
4) Allocate a workspace (cuTocta)
	cuTocta *workspace;
	cudaMallocManaged( &workspace, sizeof(cuTocta) );
	
4.5)	std::vector<cuNode> inputToctas;
		std::vector<cuNode> outputToctas;
		
4.7)	Populate inputToctas with partial single row  solutions
	
5) 	
	For each partial solution from inputToctas:
		copy partial to workspace
		call kernel code with appropriate parameters<<<nBlocks,nThreads>>>(nl_size)
			check2rows(nl_size) or check3rows(nl_size) or check4rows(nl_size)
			if ((blockDim.x * blockIdx.x) + threadIdx.x) < nl_size { ... }
		outputToctas.clear();
		analyse results area and copy any new solutions to outputToctas
		inputToctas = outputToctas;
		# inputToctas now has list of pair solutions

7)	Repeat to generate a list of triples

8)	Repeat to generate a list of solutions

9)	Publish/save solution list

10)	Stop


20) Compute environment AWS/EC2 g2.2xlarge $0.65/hr
	

30) Apply qsort and bsearch to nodelist.

	// generic compare function
	int compareNode(const void *a, const void *b) {
		if ( *(cuNode*)a < *(cuNode*)b ) return -1;
		if ( *(cuNode*)a == *(cuNode*)b ) return 0;
		if ( *(cuNode*)a > *(cuNode*)b ) return 1;
	}
	
	// compare first two primes.
	int compare2primes(const void *a, const void *b) {
		cuNode l = *(cuNode*)a;
		cuNode r = *(cuNode*)b;
		if ( l.p[0] < r.p[0] ) return -1;
		if ( l.p[0] > r.p[0] ) return  1;
		// first entries equal
		if ( l.p[1] < r.p[1] ) return -1;
		if ( l.p[1] > r.p[1] ) return  1;
		// first 2 entries equal
		return 0;
	}
	
	// compare first three primes.
	int compare3primes(const void *a, const void *b) {
		cuNode l = *(cuNode*)a;
		cuNode r = *(cuNode*)b;
		if ( l.p[0] < r.p[0] ) return -1;
		if ( l.p[0] > r.p[0] ) return  1;
		// first entries equal
		if ( l.p[1] < r.p[1] ) return -1;
		if ( l.p[1] > r.p[1] ) return  1;
		// first 2 entries equal
		if ( l.p[2] < r.p[2] ) return -1;
		if ( l.p[2] > r.p[2] ) return  1;
		// first 3 entries equal
		return 0;
	}		
		
	
	
